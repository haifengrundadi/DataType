/*
 * LinkedList.cpp
 *
 *  Created on: 2015年7月26日
 *      Author: juanecho
 */
#include <LinkedList.h>
using namespace std;

template<class T>
List<T>::List(List<T>& L)
{
	//复制构造函数
	T value;
	LinkNode<T>* srcptr = L.getHead();
	LinkNode<T>* destptr = new LinkNode<T>;
	while(srcptr->link != NULL)
	{
		value = srcptr->link->data;
		destptr->link = new LinkNode<T>(value);
		destptr= destptr->link;
		srcptr = srcptr->link;
	}
	destptr->link = NULL;
}

template <class T>
void List<T>::makeEmpty()
{
	LinkNode<T> *q;
	while(first->link != NULL)
	{
		q = first->link;
		first->link = q->link;
		delete q;
	}
}

template<class T>
int List<T>::Length() const{
	LinkNode<T> *p = first->link;
	int count = 0;
	while(p != NULL)
	{
		p = p->link;
		count++;
	}
	return count;
};

template<class T>
LinkNode<T> * List<T>::Search(T x)
{
	LinkNode<T>* current = first->link;
	while(current != NULL)
	{
		if(current->data == x)
			break;
		else
			current = current->link;
	}
	return current;
}

template < class T>
LinkNode<T>* List<T>::Locate(int i)
{
	if( i < 0)
		return NULL;
	LinkNode<T>* current = first;
	int k = 0;
	while(current != NULL && k < i)
	{
		current = current->link;
		k++;
	}
	return current;
}

template<class T>
bool List<T>::getData(int i, T& x)const
{
	if(i <= 0)
		return NULL;
	LinkNode<T> * current = this->Locate(i);
	if(current == NULL)
		return flase;
	else{
		x = current->data;
		return true;
	}

}


