/*
 * LeetCode144.cpp
 *
 *  Created on: 2015年8月3日
 *      Author: juanecho
 */

#include<iostream>
#include<vector>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };

class Solution {
public:
	int maxDepth(TreeNode* root,int total) {
		int sum = 0;
	    if(root == NULL){
	        	return 0;
	     }
	    sum += maxDepth(root->left);
	    if(sum == total)
	    	return true;
	    sum -= root->left->val;
	    sum += maxDepth(root->right,total);
	    if(sum == total)
	  	    	return true;
	  	sum -= root->left->val;
	    return sum;
	 }

	 bool hasPathSum(TreeNode* root, int sum) {
		 	 	 //深度优先算法DFS
		         if(root == NULL)
		         {
		         	return 0;
		         }
		         int left = maxDepth(root->left);
		         int right = maxDepth(root->right);
		         return left>right?left+1:right+1;
		         //若直接 return maxDepth(root->left)>maxDepth(root->right)?maxDepth(root->left)+1:maxDepth(root->right)+1;
		         //会通不过，因为用了两次的maxDepth()
	    }

	 void CreateBinTree(ifstream& in, TreeNode* &subTree)
	 {
		 int item;
		 if(!in.eof())
		 {
			 in>>item;
			 if(item!= 0)
			 {
				 subTree = new TreeNode(item);
				 CreateBinTree(in, subTree->left);
				 CreateBinTree(in, subTree->right);
			 }else
				 subTree = NULL;
		 }
	 }
};
//int main()
//	{
//		Solution * s = new Solution();
//		cout<<"output the tree--1"<<endl;
//		TreeNode* l = s->Creat();
//		s->output(l);
//		vector<int> x = s->inorderTraversal(l);
//		cout<<"output the tree--2"<<endl;
//		vector<int>::iterator it;
//		for(it=x.begin();it!=x.end();it++)
//		    cout<<*it<<endl;
//	}

